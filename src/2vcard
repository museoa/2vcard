#!/usr/bin/perl -w
use strict;

###############################################################################
#
# $Author: Jan Schaumann <jschauma@netmeister.org> $
# $Id: 2vcard v 0.4 2002-11-27 17:48:44 Jan Schaumann Exp $
#
# Copyright (c) 2001,2002 Jan Schaumann <jschauma@netmeister.org>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * The name of the author may not be used to endorse or promote products
#     derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
###############################################################################

use Getopt::Std;

my $NAME = "2vcard";
my $VERSION = "0.4";
my %SUPPORTED = ("abook" => 0, "mh" => 0, "mutt" => 1, "pine" => 0, "juno" => 0);

init();
main();
done();

#we're done - bye, bye
exit 0;


#########             #########
#########  Functions  #########
#########             #########

###
# parses command-line options etc.
###
sub init
{
		my %Options;
		my $ok = getopts('Ff:hi:o:v', \%Options);
		if (!$ok)
		{
				my $i;
				my @values = keys(%Options);
				foreach $i (@values)
				{
						if (!$Options{$i})
						{
								print STDERR "Option '$i' requires an argument.\n";
								print STDERR "Try $NAME -h for details.\n";
								exit(1);
						}
				}
		}

		open (READ, "<&STDIN") ||
			die "Can't read from STDIN-- WTF??\n";

		open (WRITE, ">&STDOUT") ||
			die "Can't write to STDOUT -- WTF??\n";

		if ($Options{'f'})
		{
				setFormat("$Options{'f'}");
		}
		if ($Options{'F'})
		{
				formats();
				exit 0;
		}
		if ($Options{'h'})
		{
				usage();
				exit 0;
		}
		if ($Options{'v'})
		{
				print "$NAME Version $VERSION\n";
				exit 0;
		}
		if ($Options{'i'})
		{
				open(READ, "$Options{'i'}") ||
						die "Can't open \"$Options{'i'}\" for reading!\n";
		}
		if ($Options{'o'})
		{
				open(WRITE, ">$Options{'o'}") ||
						die "Can't open \"$Options{'o'}\" for writing!\n";
		}

		if ($#ARGV > -1)
		{
				usage();
				exit(1);
		}
}

###
# sets the current format
###
sub setFormat
{
		my ($which) = @_;
		my $key;
		foreach $key (keys %SUPPORTED)
		{
				$SUPPORTED{"$key"} = 0;
		}
		if ($which =~ m/(abook)|(mh)|(pine)|(mutt)|(juno)/)
		{
				$SUPPORTED{"$which"} = 1;
		}
		else
		{
				print STDERR "$NAME: ERROR:\n";
				print STDERR "Format \"$which\" not supported.\n";
				print STDERR "Try \"-F\" and/or \"-h\".\n";
				exit(1);
		}
}

###
# check which format we want to read and dispatch to the proper function
###
sub main
{
		parseMutt() if ($SUPPORTED{"mutt"});
		parsePine() if ($SUPPORTED{"pine"});
		parseMH() if ($SUPPORTED{"mh"});
		parseAbook() if ($SUPPORTED{"abook"});
		parseJuno() if ($SUPPORTED{"juno"});
}

###
# cleanup before we say bye bye
###
sub done
{
		close WRITE;
		close READ;
}

###
# parses a mutt aliases file
###
sub parseMutt
{
		while (<READ>)
		{
				# alias nick email@address (full name)
				if (m/^alias (.*) (.*) \((.*)\)$/)
				{
						my @name = split / /, $3, 2;
						my $x;
						
						print WRITE "BEGIN:VCARD\n";
						print WRITE "FN:$3\n";
						print WRITE "N:";
						foreach $x (reverse @name)
						{
								print WRITE "$x;";
						}
						print WRITE "\n";

						$x = $2;
						if ($x =~ m/(.*,.*)/)
						{
								my @emails = split /,/, $1;
								foreach $x (@emails)
								{
										print WRITE "EMAIL;INTERNET:$x\n";
								}
						}
						else
						{
								print WRITE "EMAIL;INTERNET:$x\n";
						}
						print WRITE "END:VCARD\n\n";
				}
				# alias nick full name <email@address>
				elsif (m/^alias ([^\s]*) (.*) (<.*>)/)
				{
						my @name = split / /, $2, 2;
						my $x;

						print WRITE "BEGIN:VCARD\n";
						print WRITE "FN:$2\n";
						print WRITE "N:";
						foreach $x (reverse @name)
						{
								print WRITE "$x;";
						}
						print WRITE "\n";

						$x = $3;
						if ($x =~ m/(.*,.*)/)
						{
								my @emails = split /,/, $1;
								foreach $x (@emails)
								{
										$x =~ s/[<>]//g;
										print WRITE "EMAIL;INTERNET:$x\n";
								}
						}
						else
						{
								$x =~ s/[<>]//g;
								print WRITE "EMAIL;INTERNET:$x\n";
						}
						print WRITE "END:VCARD\n\n";

				}
				else
				{
						print STDERR "Skipping ill-formatted line:\n";
						print STDERR "   $_\n";
				}
		}
}

###
# parses a mh alias file
###
sub parseMH
{
		while (<READ>)
		{
				# alias: email@address, email@address
				if (m/^(.*): (.*)/)
				{
						my $x;
						
						print WRITE "BEGIN:VCARD\n";
						print WRITE "FN:$1\n";
						print WRITE "N:$1\n";

						$x = $2;
						if ($x =~ m/(.*,.*)/)
						{
								my @emails = split /,/, $1;
								foreach $x (@emails)
								{
										$x =~ s/\s//g;
										print WRITE "EMAIL;INTERNET:$x\n";
								}
						}
						else
						{
								print WRITE "EMAIL;INTERNET:$x\n";
						}
						print WRITE "END:VCARD\n\n";
				}
				else
				{
						print STDERR "Skipping ill-formatted line:\n";
						print STDERR "   $_\n";
				}
		}
}

###
# parses a pine addressbook file
###
sub parsePine
{
		while (<READ>)
		{
				# nick\tFull Name\temail@address
				# nick\tFull Name\t(email@address,email@address)
				if (m/^(.*)\t(.*)\t(.*\@.*)$/)
				{
						my @name = split / /, $2, 2;
						my $x;
						
						print WRITE "BEGIN:VCARD\n";
						print WRITE "FN:$2\n";
						print WRITE "N:";
						foreach $x (reverse @name)
						{
								print WRITE "$x;";
						}
						print WRITE "\n";

						$x = $3;
						if ($x =~ m/\((.*)\)/)
						{
								my @emails = split /,/, $1;
								foreach $x (@emails)
								{
										print WRITE "EMAIL;INTERNET:$x\n";
								}
						}
						else
						{
								print WRITE "EMAIL;INTERNET:$3\n";
						}
						print WRITE "END:VCARD\n\n";
				}
				else
				{
						print STDERR "Skipping ill-formatted line:\n";
						print STDERR "   $_\n";
				}
		}
}

###
# parses a abook addressbook file
###
sub parseAbook
{
		my $count = 0;
		my %info;
LOOP:
		while (<READ>)
		{
				# [num]
				# name=Gorden Koch
				# email=foo@bar.com,foo@barbar.com
				# address=Street
				# city=City
				# state=State
				# zip=123123
				# country=Germany
				# phone=0271/8902725
				# workphone=02352/21585
				# fax=fax
				# mobile=mobile
				# nick=Gorden
				# url=http://bl;ahlbahl.com
				# notes=CellPhone#: 01758147773

				next LOOP if (m/^#/);

				if (m/^\[\d+\]$/)
				{
						$count++;
						next LOOP;
				}

				if (m/^$/)
				{
						my $x;
						# no entries without a note
						if ($info{'name'})
						{
								my @name = split / /, $info{'name'}, 2;
								
								print WRITE "BEGIN:VCARD\n";
								print WRITE "FN:$info{'name'}\n";
								print WRITE "N:";
								foreach $x (reverse @name)
								{
										print WRITE "$x;";
								}
								print WRITE "\n";
								
								my @emails = split /,/, $info{'email'};
								foreach $x (@emails)
								{
										print WRITE "EMAIL;INTERNET:$x\n";
								}

								if ($info{'address'})
								{
										print WRITE "ADR;HOME:Default;;$info{'address'};";
										foreach $x ("city", "address", "zip", "country")
										{
												print WRITE "$info{$x};";
										}
										print WRITE "\n";
								}

								if ($info{'phone'})
								{
										print WRITE "TEL;HOME:$info{'phone'}\n";
								}
								if ($info{'workphone'})
								{
										print write "TEL;WORK:$info{'workphone'}\n";
								}
								if ($info{'fax'})
								{
										print write "TEL;FAX:$info{'fax'}\n";
								}
								if ($info{'mobile'})
								{
										print write "TEL;CELL:$info{'mobile'}\n";
								}

								if ($info{'url'})
								{
										print WRITE "URL:$info{'url'}\n";
								}
								if ($info{'notes'})
								{
										print WRITE "NOTE:$info{'notes'}\n";
								}

								print WRITE "END:VCARD\n\n";
								
						}

						foreach $x (keys %info)
						{
								$info{$x} = "";
						}
						next LOOP;
				}

				if ($count)
				{
						my ($key, $val) = split /=/;
						if ($val)
						{
								chomp($val);
								$info{$key} = $val;
						}
						next LOOP;
				}
		}
}

###
# parses a Juno address book export file
###
sub parseJuno
{
	my $count = 0;
	my %info;
LOOP:
	while (<READ>)
	{
		# Type:Entry
		# Name:Burdell, George P.
		# Email:burdell@gatech.edu,gburdell@cc.gatech.edu
		# Alias:YellowJacket

		next LOOP if (m/^#/);

		if (m/^Type:Entry$/)
		{
			$count++;
			next LOOP;
		}

		if (m/^$/)
		{
			my $x;
			# no entries without a note
			if ($info{'Name'})
			{
				my @name = split /,/, $info{'Name'}, 2;

				print WRITE "BEGIN:VCARD\n";
				print WRITE "FN:";
				foreach $x (reverse @name)
				{
					# Trim leading/trailing whitespace
					$x =~ s/^\s+//;
					$x =~ s/\s+$//;
					print WRITE "$x ";
				}
				print WRITE "\n";
				print WRITE "N:";
				foreach $x (@name)
				{
					# Trim leading/trailing whitespace
					$x =~ s/^\s+//;
					$x =~ s/\s+$//;
					print WRITE "$x;";
				}
				print WRITE "\n";

				my @emails = split /,/, $info{'Email'};
				foreach $x (@emails)
				{
					print WRITE "EMAIL;INTERNET:$x\n";
				}

				if ($info{'Alias'})
				{
					print WRITE "NOTE:$info{'Alias'}\n";
				}

				print WRITE "END:VCARD\n\n";

			}

			foreach $x (keys %info)
			{
				$info{$x} = "";
			}
			next LOOP;
		}

		if ($count)
		{
			my ($key, $val) = split /:/;
			if ($val)
			{
				chomp($val);
				$info{$key} = $val;
			}
			next LOOP;
		}
	}
}

###
# prints a list of supported formats
###
sub formats
{
		my $key;

		print "$NAME $VERSION can convert the addressbooks of the following:\n";
		foreach $key (sort(keys %SUPPORTED))
		{
				print "\t$key\n";
		}
}

###
# prints out helpful information
###
sub usage
{
		print "$NAME: convert an addressbook to vcard format\n";
		print "Usage: $NAME [OPTION...]\n";
		print "Options:\n";
		print "  -F\t\tshow supported formats\n";
		print "  -f FORMAT\tconvert from FROMAT [ default: mutt ]\n";
		print "  -h\t\tprint this message and exit\n";
		print "  -i FILE\tread input from FILE\n";
		print "  -o FILE\twrite output to FILE\n";
		print "  -v\t\tprint version number and exit\n";
}
