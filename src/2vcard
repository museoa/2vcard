#!/usr/bin/perl -w
use strict;

###############################################################################
#
# $Author: Jan Schaumann <jschauma@netmeister.org> $
# $Id: 2vcard v 0.3 2001-09-24 13:58:44 Jan Schaumann Exp $
#
# Copyright (c) 2001, Jan Schaumann <jschauma@netmeister.org>
# All rights reserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
###############################################################################

use Getopt::Std;

my $NAME = "2vcard";
my $VERSION = "0.3";
my %SUPPORTED = ("abook" => 0, "mh" => 0, "mutt" => 1, "pine" => 0);

init();
main();
done();

#we're done - bye, bye
exit 0;


#########             #########
#########  Functions  #########
#########             #########

###
# parses command-line options etc.
###
sub init
{
		my %Options;
		my $ok = getopts('Ff:hi:o:v', \%Options);
		if (!$ok)
		{
				my $i;
				my @values = keys(%Options);
				foreach $i (@values)
				{
						if (!$Options{$i})
						{
								print STDERR "Option '$i' requires an argument.\n";
								print STDERR "Try $NAME -h for details.\n";
								exit(1);
						}
				}
		}

		open (READ, "<&STDIN") ||
			die "Can't read from STDIN-- WTF??\n";

		open (WRITE, ">&STDOUT") ||
			die "Can't write to STDOUT -- WTF??\n";

		if ($Options{'f'})
		{
				setFormat("$Options{'f'}");
		}
		if ($Options{'F'})
		{
				formats();
				exit 0;
		}
		if ($Options{'h'})
		{
				usage();
				exit 0;
		}
		if ($Options{'v'})
		{
				print "$NAME Version $VERSION\n";
				exit 0;
		}
		if ($Options{'i'})
		{
				open(READ, "$Options{'i'}") ||
						die "Can't open \"$Options{'i'}\" for reading!\n";
		}
		if ($Options{'o'})
		{
				open(WRITE, ">$Options{'o'}") ||
						die "Can't open \"$Options{'o'}\" for writing!\n";
		}

		if ($#ARGV > -1)
		{
				usage();
				exit(1);
		}
}

###
# sets the current format
###
sub setFormat
{
		my ($which) = @_;
		my $key;
		foreach $key (keys %SUPPORTED)
		{
				$SUPPORTED{"$key"} = 0;
		}
		if ($which =~ m/(abook)|(mh)|(pine)|(mutt)/)
		{
				$SUPPORTED{"$which"} = 1;
		}
		else
		{
				print STDERR "$NAME: ERROR:\n";
				print STDERR "Format \"$which\" not supported.\n";
				print STDERR "Try \"-F\" and/or \"-h\".\n";
				exit(1);
		}
}

###
# check which format we want to read and dispatch to the proper function
###
sub main
{
		parseMutt() if ($SUPPORTED{"mutt"});
		parsePine() if ($SUPPORTED{"pine"});
		parseMH() if ($SUPPORTED{"mh"});
		parseAbook() if ($SUPPORTED{"abook"});
}

###
# cleanup before we say bye bye
###
sub done
{
		close WRITE;
		close READ;
}

###
# parses a mutt aliases file
###
sub parseMutt
{
		while (<READ>)
		{
				# alias nick email@address (full name)
				if (m/^alias (.*) (.*) \((.*)\)$/)
				{
						my @name = split / /, $3, 2;
						my $x;
						
						print WRITE "BEGIN:VCARD\n";
						print WRITE "FN:$3\n";
						print WRITE "N:";
						foreach $x (reverse @name)
						{
								print WRITE "$x;";
						}
						print WRITE "\n";

						$x = $2;
						if ($x =~ m/(.*,.*)/)
						{
								my @emails = split /,/, $1;
								foreach $x (@emails)
								{
										print WRITE "EMAIL;INTERNET:$x\n";
								}
						}
						else
						{
								print WRITE "EMAIL;INTERNET:$x\n";
						}
						print WRITE "END:VCARD\n\n";
				}
				# alias nick full name <email@address>
				elsif (m/^alias ([^\s]*) (.*) (<.*>)/)
				{
						my @name = split / /, $2, 2;
						my $x;

						print WRITE "BEGIN:VCARD\n";
						print WRITE "FN:$2\n";
						print WRITE "N:";
						foreach $x (reverse @name)
						{
								print WRITE "$x;";
						}
						print WRITE "\n";

						$x = $3;
						if ($x =~ m/(.*,.*)/)
						{
								my @emails = split /,/, $1;
								foreach $x (@emails)
								{
										$x =~ s/[<>]//g;
										print WRITE "EMAIL;INTERNET:$x\n";
								}
						}
						else
						{
								$x =~ s/[<>]//g;
								print WRITE "EMAIL;INTERNET:$x\n";
						}
						print WRITE "END:VCARD\n\n";

				}
				else
				{
						print STDERR "Skipping ill-formatted line:\n";
						print STDERR "   $_\n";
				}
		}
}

###
# parses a mh alias file
###
sub parseMH
{
		while (<READ>)
		{
				# alias: email@address, email@address
				if (m/^(.*): (.*)/)
				{
						my $x;
						
						print WRITE "BEGIN:VCARD\n";
						print WRITE "FN:$1\n";
						print WRITE "N:$1\n";

						$x = $2;
						if ($x =~ m/(.*,.*)/)
						{
								my @emails = split /,/, $1;
								foreach $x (@emails)
								{
										$x =~ s/\s//g;
										print WRITE "EMAIL;INTERNET:$x\n";
								}
						}
						else
						{
								print WRITE "EMAIL;INTERNET:$x\n";
						}
						print WRITE "END:VCARD\n\n";
				}
				else
				{
						print STDERR "Skipping ill-formatted line:\n";
						print STDERR "   $_\n";
				}
		}
}

###
# parses a pine addressbook file
###
sub parsePine
{
		while (<READ>)
		{
				# nick\tFull Name\temail@address
				# nick\tFull Name\t(email@address,email@address)
				if (m/^(.*)\t(.*)\t(.*\@.*)$/)
				{
						my @name = split / /, $2, 2;
						my $x;
						
						print WRITE "BEGIN:VCARD\n";
						print WRITE "FN:$2\n";
						print WRITE "N:";
						foreach $x (reverse @name)
						{
								print WRITE "$x;";
						}
						print WRITE "\n";

						$x = $3;
						if ($x =~ m/\((.*)\)/)
						{
								my @emails = split /,/, $1;
								foreach $x (@emails)
								{
										print WRITE "EMAIL;INTERNET:$x\n";
								}
						}
						else
						{
								print WRITE "EMAIL;INTERNET:$3\n";
						}
						print WRITE "END:VCARD\n\n";
				}
				else
				{
						print STDERR "Skipping ill-formatted line:\n";
						print STDERR "   $_\n";
				}
		}
}

###
# parses a abook addressbook file
###
sub parseAbook
{
		my $count = 0;
		my %info;
LOOP:
		while (<READ>)
		{
				# [num]
				# name=Gorden Koch
				# email=foo@bar.com,foo@barbar.com
				# address=Street
				# city=City
				# state=State
				# zip=123123
				# country=Germany
				# phone=0271/8902725
				# workphone=02352/21585
				# fax=fax
				# mobile=mobile
				# nick=Gorden
				# url=http://bl;ahlbahl.com
				# notes=CellPhone#: 01758147773

				next LOOP if (m/^#/);

				if (m/^\[\d+\]$/)
				{
						$count++;
						next LOOP;
				}

				if (m/^$/)
				{
						my $x;
						# no entries without a note
						if ($info{'name'})
						{
								my @name = split / /, $info{'name'}, 2;
								
								print WRITE "BEGIN:VCARD\n";
								print WRITE "FN:$info{'name'}\n";
								print WRITE "N:";
								foreach $x (reverse @name)
								{
										print WRITE "$x;";
								}
								print WRITE "\n";
								
								my @emails = split /,/, $info{'email'};
								foreach $x (@emails)
								{
										print WRITE "EMAIL;INTERNET:$x\n";
								}

								if ($info{'address'})
								{
										print WRITE "ADR;HOME:Default;;$info{'address'};";
										foreach $x ("city", "address", "zip", "country")
										{
												print WRITE "$info{$x};";
										}
										print WRITE "\n";
								}

								if ($info{'phone'})
								{
										print WRITE "TEL;HOME:$info{'phone'}\n";
								}
								if ($info{'workphone'})
								{
										print write "TEL;WORK:$info{'workphone'}\n";
								}
								if ($info{'fax'})
								{
										print write "TEL;FAX:$info{'fax'}\n";
								}
								if ($info{'mobile'})
								{
										print write "TEL;CELL:$info{'mobile'}\n";
								}

								if ($info{'url'})
								{
										print WRITE "URL:$info{'url'}\n";
								}
								if ($info{'notes'})
								{
										print WRITE "NOTE:$info{'notes'}\n";
								}

								print WRITE "END:VCARD\n\n";
								
						}

						foreach $x (keys %info)
						{
								$info{$x} = "";
						}
						next LOOP;
				}

				if ($count)
				{
						my ($key, $val) = split /=/;
						if ($val)
						{
								chomp($val);
								$info{$key} = $val;
						}
						next LOOP;
				}
		}
}

###
# prints a list of supported formats
###
sub formats
{
		my $key;

		print "$NAME $VERSION can convert the addressbooks of the following:\n";
		foreach $key (sort(keys %SUPPORTED))
		{
				print "\t$key\n";
		}
}

###
# prints out helpful information
###
sub usage
{
		print "$NAME: convert an addressbook to vcard format\n";
		print "Usage: $NAME [OPTION...]\n";
		print "Options:\n";
		print "  -F\t\tshow supported formats\n";
		print "  -f FORMAT\tconvert from FROMAT [ default: mutt ]\n";
		print "  -h\t\tprint this message and exit\n";
		print "  -i FILE\tread input from FILE\n";
		print "  -o FILE\twrite output to FILE\n";
		print "  -v\t\tprint version number and exit\n";
}
